import * as Parser from './parser';
import DataBuffer from './data-buffer';
import DerivedBuffer from './derived-buffer';
import Image from './image';
import Tile, { TileAggregation } from './tile';
import Color from './color';
import * as Scale from './scale';
import Mask from './mask';
export default class Interpreter {
    configuration: Parser.Configuration;
    description?: string;
    width: number;
    height: number;
    n: number;
    sourceBuffers: DataBuffer[];
    dataBuffers: DataBuffer[];
    dataSpec: Parser.DataSpec;
    derivedBuffers: DerivedBuffer[];
    blurredBuffers: DerivedBuffer[];
    image: Image[];
    tiles: Tile[];
    tileAggregation: TileAggregation;
    strokeCanvas: boolean;
    backgroundStroke: string;
    fillCanvas: boolean;
    background?: string;
    bufferNames: string[];
    colors0: Color[];
    colors1: Color[];
    rebin: any;
    rescale: Parser.RescaleSpec;
    compose: Parser.ComposeSpec;
    composer: (buffers: DerivedBuffer[], values: number[]) => Color;
    masks: Mask[];
    maskStroke?: string;
    contour: Parser.ContourSpec;
    blur: number;
    geo: Parser.GeoSpec;
    legend: Parser.LegendSpec | false;
    scale: Scale.ScaleTrait;
    xdomain: Parser.NumPair;
    ydomain: Parser.NumPair;
    stroke?: Parser.StrokeSpec;
    axis?: Parser.AxisSpec;
    d3scale: string;
    d3base: number;
    d3exponent: number;
    constructor(configuration: Parser.Configuration);
    interpret(context?: {}): void;
    private computeDerivedBuffers(context?);
    private computeRebin(context?);
    private computeCompose(context?);
    private setup(canvas, forcedWidth?, forcedHeight?);
    private renderMap(canvas);
    render(id: string | HTMLDivElement, forcedWidth?: number, forcedHeight?: number): void;
    private renderAxis(map, native, forcedWidth?, forcedHeight?);
    private renderStroke(canvas);
    pickDomains(x: number, y: number): [number, number] | null;
    pickValues(x: number, y: number): number[];
    pickTile(x: number, y: number): Tile | null;
}
